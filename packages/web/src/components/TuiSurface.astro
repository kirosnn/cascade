<div class="tui-visual-container">
  <canvas id="tui-canvas"></canvas>
</div>

<style>
  .tui-visual-container {
    width: 100%;
    height: 320px;
    position: relative;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

<script>
  // TUI Constants
  const CELL_W = 10;
  const CELL_H = 18;
  const FONT = '14px "IBM Plex Mono", monospace';
  
  class Renderer {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    cols: number = 0;
    rows: number = 0;
    dpr: number = 1;
    
    // Theme colors
    colors = {
      bg: 'transparent',
      fg: '#666',      // --color-text
      fgStrong: '#1f1f1f', // --color-text-strong
      fgWeak: '#999',  // --color-text-weak
      border: '#e5e5e5', // --color-border
    };
    
    syntax = {
      keyword: '#6366f1',
      string: '#059669',
      function: '#0891b2',
      component: '#9333ea',
      punctuation: '#71717a',
      text: '#3f3f46',
    };

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d')!;
      this.updateTheme();
      this.resize();
      
      const resizeObserver = new ResizeObserver(() => this.resize());
      resizeObserver.observe(canvas.parentElement!);
      
      // Watch for system theme changes
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => this.updateTheme());
    }
    
    updateTheme() {
      const style = getComputedStyle(document.documentElement);
      this.colors.fg = style.getPropertyValue('--color-text').trim() || '#666';
      this.colors.fgStrong = style.getPropertyValue('--color-text-strong').trim() || '#111';
      this.colors.fgWeak = style.getPropertyValue('--color-text-weak').trim() || '#999';
      this.colors.border = style.getPropertyValue('--color-border').trim() || '#eee';
      
      // Update syntax colors based on theme
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      if (isDark) {
        this.syntax = {
          keyword: '#c9a0dc',
          string: '#a5d6a7',
          function: '#7dd3fc',
          component: '#e0b0ff',
          punctuation: '#a0a0a0',
          text: '#e0e0e0',
        };
      } else {
        this.syntax = {
          keyword: '#6366f1',
          string: '#059669',
          function: '#0891b2',
          component: '#9333ea',
          punctuation: '#71717a',
          text: '#3f3f46',
        };
      }
    }

    resize() {
      const parent = this.canvas.parentElement!;
      this.dpr = window.devicePixelRatio || 1;
      const rect = parent.getBoundingClientRect();
      
      this.canvas.width = rect.width * this.dpr;
      this.canvas.height = rect.height * this.dpr;
      this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
      
      this.cols = Math.floor(rect.width / CELL_W);
      this.rows = Math.floor(rect.height / CELL_H);
    }

    clear() {
      this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);
    }

    drawChar(char: string, x: number, y: number, fg: string, bg?: string) {
      if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return;
      
      const px = x * CELL_W;
      const py = y * CELL_H;

      if (bg) {
        this.ctx.fillStyle = bg;
        this.ctx.fillRect(px, py, CELL_W, CELL_H);
      }

      this.ctx.font = FONT;
      this.ctx.textBaseline = 'top';
      this.ctx.fillStyle = fg;
      this.ctx.fillText(char, px, py + 2);
    }

    drawBox(x: number, y: number, w: number, h: number, fg: string, style: 'single' | 'double' | 'bold' = 'single', label?: string) {
      const c = style === 'double' ? { tl: '╔', tr: '╗', bl: '╚', br: '╝', h: '═', v: '║' } :
                style === 'bold'   ? { tl: '┏', tr: '┓', bl: '┗', br: '┛', h: '━', v: '┃' } :
                                     { tl: '┌', tr: '┐', bl: '└', br: '┘', h: '─', v: '│' };

      // Corners
      this.drawChar(c.tl, x, y, fg);
      this.drawChar(c.tr, x + w - 1, y, fg);
      this.drawChar(c.bl, x, y + h - 1, fg);
      this.drawChar(c.br, x + w - 1, y + h - 1, fg);

      // Edges
      for (let i = 1; i < w - 1; i++) {
        this.drawChar(c.h, x + i, y, fg);
        this.drawChar(c.h, x + i, y + h - 1, fg);
      }
      for (let i = 1; i < h - 1; i++) {
        this.drawChar(c.v, x, y + i, fg);
        this.drawChar(c.v, x + w - 1, y + i, fg);
      }
      
      // Label with spacing: ┌─ Label ─┐
      if (label) {
        const paddedLabel = ` ${label} `;
        for (let i = 0; i < paddedLabel.length; i++) {
          const lx = x + 1 + i;
          if (lx < x + w - 1) {
            // Clear the cell first to remove the border character
            const px = lx * CELL_W;
            const py = y * CELL_H;
            this.ctx.clearRect(px, py, CELL_W, CELL_H);
            this.drawChar(paddedLabel[i], lx, y, fg);
          }
        }
      }
    }
    
    drawText(text: string, x: number, y: number, fg: string) {
      for (let i = 0; i < text.length; i++) {
        this.drawChar(text[i], x + i, y, fg);
      }
    }
  }

  // State
  let activeFeature = 'layout';
  
  // Listen for feature changes
  window.addEventListener('feature-change', (e: any) => {
    activeFeature = e.detail;
  });

  const canvas = document.getElementById('tui-canvas') as HTMLCanvasElement;
  if (canvas) {
    const r = new Renderer(canvas);
    
    function animate(time: number) {
      r.clear();
      const t = time / 1000; // seconds
      
      const cx = Math.floor(r.cols / 2);
      const cy = Math.floor(r.rows / 2);

      switch (activeFeature) {
        case 'layout': {
          // Slow breathing layout
          const phase = (Math.sin(t) + 1) / 2; // 0 to 1
          const gap = 2;
          const totalW = 40;
          const h = 10;
          
          const wLeft = Math.floor(10 + phase * 10); // 10 to 20
          const wRight = totalW - wLeft;
          
          const startX = cx - (totalW + gap) / 2;
          const startY = cy - h / 2;
          
          r.drawBox(Math.floor(startX), Math.floor(startY), wLeft, h, r.colors.fgStrong, 'single', 'Nav');
          r.drawBox(Math.floor(startX + wLeft + gap), Math.floor(startY), wRight, h, r.colors.fg, 'single', 'Content');
          
          // Show dimensions
          r.drawText(`${wLeft}w`, Math.floor(startX), Math.floor(startY) - 1, r.colors.fgWeak);
          r.drawText(`${wRight}w`, Math.floor(startX + wLeft + gap), Math.floor(startY) - 1, r.colors.fgWeak);
          break;
        }
        
        case 'syntax': {
          const code = [
            "import { Text } from 'tui'",
            "",
            "function App() {",
            "  return (",
            "    <Text color='green'>",
            "      Hello World",
            "    </Text>",
            "  )",
            "}"
          ];
          
          const startX = cx - 15;
          const startY = cy - 5;
          
          const cycleLength = code.length + 4;
          const scanRow = Math.floor(t * 2) % cycleLength;
          
          const keywords = ['import', 'from', 'function', 'return', 'const'];
          const components = ['Text'];
          
          code.forEach((line, i) => {
            const isCurrentLine = i === scanRow;
            const isHighlighted = i <= scanRow;
            
            const tokens = line.split(/(\s+|[{}()<>='",;/]|'[^']*')/).filter(Boolean);
            let lx = startX;
            
            tokens.forEach(token => {
               let color = r.colors.fgWeak;
               
               if (isHighlighted) {
                  if (keywords.includes(token)) {
                     color = r.syntax.keyword;
                  } else if (components.includes(token)) {
                     color = r.syntax.component;
                  } else if (token.startsWith("'") && token.endsWith("'")) {
                     color = r.syntax.string;
                  } else if (/^[{}()<>=,;]$/.test(token)) {
                     color = r.syntax.punctuation;
                  } else if (token === 'App') {
                     color = r.syntax.function;
                  } else if (token.trim()) {
                     color = r.syntax.text;
                  }
               }
               
               r.drawText(token, lx, startY + i, color);
               lx += token.length;
            });
            
            if (isCurrentLine && scanRow < code.length) {
               r.drawChar('│', startX - 2, startY + i, r.colors.fgStrong);
            }
          });
          break;
        }

        case 'components': {
          // Focus cycling
          const step = Math.floor(t / 1.5) % 3;
          
          const startX = cx - 12;
          const startY = cy - 6;
          
          // Input
          r.drawText("Username:", startX, startY, r.colors.fg);
          const f1 = step === 0;
          r.drawBox(startX, startY + 1, 24, 3, f1 ? r.colors.fgStrong : r.colors.border, f1 ? 'double' : 'single');
          r.drawText(f1 ? "Simon|" : "Simon", startX + 2, startY + 2, f1 ? r.colors.fgStrong : r.colors.fg);
          
          // Select
          r.drawText("Role:", startX, startY + 5, r.colors.fg);
          const f2 = step === 1;
          r.drawBox(startX, startY + 6, 24, 3, f2 ? r.colors.fgStrong : r.colors.border, f2 ? 'double' : 'single');
          r.drawText("Developer ▼", startX + 2, startY + 7, f2 ? r.colors.fgStrong : r.colors.fg);
          
          // Button
          const f3 = step === 2;
          r.drawBox(startX + 14, startY + 10, 10, 3, f3 ? r.colors.fgStrong : r.colors.border, f3 ? 'bold' : 'single');
          r.drawText("Save", startX + 17, startY + 11, f3 ? r.colors.fgStrong : r.colors.fg);
          break;
        }
        
        case 'keyboard': {
           const items = [" Dashboard", " Settings", " Profile", " Logout"];
           const idx = Math.floor(t * 1.5) % 4;
           
           const startX = cx - 10;
           const startY = cy - 5;
           
           r.drawBox(startX, startY, 20, 8, r.colors.border, 'single', 'Menu');
           
           items.forEach((item, i) => {
             const active = i === idx;
             r.drawText(
               (active ? ">" : " ") + item, 
               startX + 2, 
               startY + 2 + i, 
               active ? r.colors.fgStrong : r.colors.fg
             );
           });
           break;
        }
        
        case 'react': {
           // Component tree
           const startX = cx;
           const startY = cy - 4;
           
           r.drawBox(startX - 4, startY, 8, 3, r.colors.fgStrong, 'single', 'App');
           
           // Lines
           r.drawChar('│', startX, startY + 3, r.colors.border);
           r.drawChar('┌', startX - 6, startY + 4, r.colors.border);
           r.drawChar('─', startX - 5, startY + 4, r.colors.border);
           r.drawChar('─', startX - 4, startY + 4, r.colors.border);
           r.drawChar('─', startX - 3, startY + 4, r.colors.border);
           r.drawChar('─', startX - 2, startY + 4, r.colors.border);
           r.drawChar('─', startX - 1, startY + 4, r.colors.border);
           r.drawChar('┴', startX, startY + 4, r.colors.border);
           r.drawChar('─', startX + 1, startY + 4, r.colors.border);
           r.drawChar('─', startX + 2, startY + 4, r.colors.border);
           r.drawChar('─', startX + 3, startY + 4, r.colors.border);
           r.drawChar('─', startX + 4, startY + 4, r.colors.border);
           r.drawChar('─', startX + 5, startY + 4, r.colors.border);
           r.drawChar('┐', startX + 6, startY + 4, r.colors.border);
           
           r.drawChar('│', startX - 6, startY + 5, r.colors.border);
           r.drawChar('│', startX + 6, startY + 5, r.colors.border);
           
           // Update pulse
           const pulse = Math.floor(t) % 2 === 0;
           
           r.drawBox(startX - 10, startY + 6, 8, 3, pulse ? r.colors.fgStrong : r.colors.fgWeak, 'single', 'List');
           r.drawBox(startX + 2, startY + 6, 8, 3, !pulse ? r.colors.fgStrong : r.colors.fgWeak, 'single', 'Item');
           
           break;
        }

        case 'animations': {
           // Ball bounce
           const w = 30;
           const h = 12;
           const startX = cx - w/2;
           const startY = cy - h/2;
           
           r.drawBox(startX, startY, w, h, r.colors.border);
           
           const bx = Math.abs(Math.sin(t) * (w - 3));
           const by = Math.abs(Math.cos(t * 0.8) * (h - 3));
           
           // Draw trail
           for(let i=1; i<4; i++) {
             const ti = t - i * 0.1;
             const tx = Math.abs(Math.sin(ti) * (w - 3));
             const ty = Math.abs(Math.cos(ti * 0.8) * (h - 3));
             r.drawChar('·', startX + 1 + tx, startY + 1 + ty, r.colors.border);
           }
           
           r.drawChar('●', startX + 1 + bx, startY + 1 + by, r.colors.fgStrong);
           break;
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    requestAnimationFrame(animate);
  }
</script>
